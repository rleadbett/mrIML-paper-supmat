# Co-occurance simulations

```{r}
#| message: false
#| warning: false
#| results: "hide"
# Load required packages
# Data manipulation
library(here)
library(readxl)
library(tidyverse)
library(DT)
# Modeling
library(mrIML)
library(tidymodels)
library(future)
library(finetune)
library(flashlight)
# Plotting
library(igraph)
library(ggnetwork)
library(cowplot)
library(patchwork)

library(seqtime)

# Load custom functions
source(here("R-functions", "select_variables.r"))
source(here("R-functions", "plot_network.r"))

# Set random seed
set.seed(109)

# Set up parallel processing
n_cores <- parallel::detectCores()
plan("multicore", workers = n_cores - 2)

# Load simulated data
source(
  here("sim-study", "symetric-sims.r")
)
```

```{r}
network_size <- 20
k_average <- 4

simulated_network <- generateM_specific_type(
  nn = network_size,
  k_ave = k_average,
  type.network = "random",
  type.interact = "mix",
  interact.str.max = 0.4,
  mix.compt.ratio = 0.5
)
true_network <- simulated_network[[1]]
M <- simulated_network[[2]]
```

```{r}
## plot population dynamics
y <- rpois(network_size, lambda = 100) #initial abundance
r <- runif(network_size) #growth rates
res <- glv(network_size, M, r, y)
tsplot(10 * res[, 20:1000], time.given = T)
```

```{r}
data <- generateDataSet(
  1000,
  M,
  count = network_size * 10000,
  mode = 4
) %>%
  t() %>%
  as.data.frame() %>%
  mutate(
    across(everything(), ~ ifelse(. < 1, yes = 0, no = 1))
  )
```

```{r}
Y <- filterRareCommon(data, lower = 0.01, higher = 0.99)
X1 <- Y
```

```{r}
model_rf <- rand_forest(
  trees = 100,
  mode = "classification",
  mtry = tune(),
  min_n = tune()
) %>%
  set_engine("randomForest")
```

```{r}
yhats_rf_sim <- mrIMLpredicts(
  Y = Y,
  X = NULL,
  X1 = X1,
  Model = model_rf,
  prop = 0.7,
  k = 5,
  racing = TRUE
)
```

```{r}
bs_sim <- mrBootstrap(yhats_rf_sim)
```

```{r}
assoc_net <- mrCoOccurNet(bs_sim)
```

```{r}
mrIML_mat <- assoc_net %>%
  filter(mean_strength > 0.1) %>%
  mutate(
    mean_strength_dir = ifelse(
      direction == "negative",
      yes = -mean_strength,
      no = mean_strength
    ),
    across(contains("taxa"), ~ sub("^sp", "", .))
  ) %>%
  graph_from_data_frame(
    directed = FALSE,
    vertices = sub("^sp", "", names(Y))
  ) %>%
  get.adjacency(attr = "mean_strength_dir", sparse = FALSE)

#plots
g_mrIML <- graph_from_adjacency_matrix(
  mrIML_mat,
  mode = 'undirected',
  weighted = T,
  diag = F
)

edge_colors_mrIML <- ifelse(E(g_mrIML)$weight < 0, yes = "red", no = "blue")
edge_widths_mrIML <- abs(E(g_mrIML)$weight) * 10 # Adjust the scaling factor as needed
matching_indices <- as.numeric(rownames(mrIML_mat))

true_mat <- M[matching_indices, matching_indices]
rownames(true_mat) <- rownames(mrIML_mat)
colnames(true_mat) <- rownames(mrIML_mat)
g_true <- graph_from_adjacency_matrix(
  true_mat,
  mode = 'undirected',
  weighted = T,
  diag = F
)
edge_colors_true <- ifelse(E(g_true)$weight < 0, yes = "red", no = "blue")
edge_widths_true <- abs(E(g_true)$weight) * 5 # Adjust the scaling factor as needed

layout1 <- layout_nicely(g_true)

par_old <- par(mfrow = c(1, 2))

plot(
  g_mrIML,
  layout = layout1,
  edge.color = edge_colors_mrIML,
  edge.width = edge_widths_mrIML,
  isolates = TRUE,
  main = "mrIML co-occurence"
)

plot(
  g_true,
  layout = layout1,
  edge.color = edge_colors_true,
  isolates = TRUE,
  edge.width = edge_widths_true,
  main = "simulated co-occurence"
)

par(par_old)
```

```{r}
dist_mat_true <- 1 - true_mat #something is wronghere
dist_mat_mrIML <- 1 - mrIML_mat
mantel_result <- vegan::mantel(dist_mat_true, dist_mat_mrIML, method = "pearson")
mantel_result
```

## Mutualistic

## Competitive

## Mixed

# Asymetric simulations